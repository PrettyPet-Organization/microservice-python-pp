# Задача 49 - Создать модели приложения “Profiles”

## Составлены модели
### awards.py
- awards - это модель наград, которые может получать пользователь.
- Награды имеют уникальное имя.

### cities.py
- cities - это модель городов, где может проживать пользователь.
- Города имеют уникальное имя.

### hobbies.py
- hobbies - это модель хобби, которые может иметь пользователь.
- Хобби имеют уникальное имя.

### profile_roles.py
- profile_roles - это модель ролей, которые могут иметь пользователи.
- Роли имеют уникальное имя.
- Один пользователь может иметь несколько ролей.

### profiles.py
- profile - это модель профиля, которая связана с пользователем.
- Profile имеет следующие поля:
  - birth_date - дата рождения.
  - description - описание.
  - photo_url - url фотографии.
  - public_name - публичное имя.
  - city - город, где проживает пользователь (foreign key).
  - awards - награды, которые получил пользователь (many to many).
  - hobbies - хобби, которые имеет пользователь (many to many).
  - roles - роли, которые имеет пользователь (many to many).

## Примечания
- Поменял поле age на дату рождения, сделал возможность получать возраст через @property

- Работу с датой рождения организовал в виде @property и сеттера, чтобы валидировать значения на уровне объекта python. Пояснение: по умолчанию полям модели можно присвоить любые значения и работать с ними на уровне объекта python (ибо все они считаются Any или типа того), но чтобы save() не выкинул исключение, полю типа DateField можно присвоить только значения типа datetime.date или str в формате "YYYY-MM-DD", а при выдаче сохраненной записи из БД мы всегда получаем поле типа datetime.date. Поэтому для комфортной работы (например, для корректного вычисления age) и отладки было решено использовать сеттер, который позволяет записать в поле даты рождения только datetime.date либо str, который сеттер автоматически преобразует в datetime.date

- Добавил модель Hobby() (ранее у профайла было поле CharField для хобби - странновасто)

- Убрал валидацию изображения. Я так понимаю, изображения будут храниться в удаленном хранилище, так вот, пусть оно хранит/отдаёт отформатированные изображения

- Модель City(), на мой взгляд, следует заменить на Address() и хранить в ней поля страны и города. Рекомендую присмотреться к django-address

- **`НЕОБХОДИМО ОТОБРАЗИТЬ ЭТО ВСЁ В СХЕМЕ БД`**

- Хорошо бы вынести енум RoleLevel куда-то, чтобы это могли переиспользовать, например, проекты, чтобы можно было указать не только количество требуемых участников с соответствующими ролями, но и их уровень

- **`ЧЕЛЫ, ИСПОЛЬЗУЙТЕ НОРМАЛЬНЫЕ ФИКСТУРЫ`**. Я сделал их в виде json и разбил по файлам, чтобы не повторяться при формировании каких-либо тестовых объектов. Сделал на коленке команду, которая вызывает загрузку фикстур для приложения profiles - **`ЕЁ НУЖНО ПРИВЕСТИ В ЧЕЛОВЕЧЕСКИЙ ВИД`**. Также при создании фикстур я не создаю связи (кроме обязательных),**` НУЖНО ДОПОЛНИТЬ`**. **`ВЫЗОВ КОМАНДЫ ЗАГРУЗКИ ФИКСТУР`**: 
```shell
python manage.py create_profile_instances
```

- Поправил core/views/check_system.py

- Настроил .toml - можно юзать isort и black независимо друг от друга (**`НАДО БЫ ПРЕКОММИТЫ НАСТРОИТЬ В СООТВЕТСТВИЕ С ЭТИМ`**)

- Считаю, чтобы соблюдать DRY, а также избежать множества циклических импортов, из-за которых мы вынуждены использовать ленивую загрузку (указывать модели в кавычках), необходимо сделать миксины, которые зададут хотя бы такие поля как description, photo_url, связи с roles, tools, tags, groups, awards (ну и поля/связи для событийно-подобных сущностей, такие как запрос на участие, связь с профайлами (последнее можно также использовать как миксин для новостей, наград, материалов, а также промежуточных many2many таблиц)). Также можно сделать миксин для автообёртывания вербос_неймов полей модели в gettext_lazy() и декоратор (или что-нибудь ещё) для того же относительно сообщений об ошибках

- **`СЛЕДУЕТ ЗАМЕНИТЬ`** все записи типа "from app.models.app_model import AppModel" на "from app.models import AppModel", ибо во всех models/__init__.py уже прописано (должно быть прописано) "from app.models.app_model import *"